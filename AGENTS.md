## Git Workflow: NO Pull Requests

**CRITICAL: NEVER create Pull Requests. All merges happen locally via squash merge.**

### Rules
- **NEVER use `gh pr create`** or any PR creation command
- **NEVER suggest creating a PR**
- Feature branches are merged via **local squash merge**

### Workflow for Features
1. Create feature branch: `git checkout -b feature/my-feature`
2. Make commits, push to remote: `git push -u origin feature/my-feature`
3. When ready, squash merge locally (from main worktree):
   ```bash
   git checkout main
   git fetch origin
   git merge --squash origin/feature/my-feature
   git commit
   git push
   ```

### Bug Fixes
- Bug fixes go directly to `main` branch (no feature branch needed)
- Commit and push directly: `git push origin main`

## Project Overview

**embache** is a standalone Rust library that wraps AI CLI tools (Claude Code, Copilot, Cursor Agent, OpenCode) as pluggable LLM providers via subprocess execution.

### Architecture
```
src/
‚îú‚îÄ‚îÄ lib.rs           # Re-exports all runners + shared types
‚îú‚îÄ‚îÄ types.rs         # Standalone types: RunnerError, LlmProvider trait, ChatRequest, etc.
‚îú‚îÄ‚îÄ config.rs        # RunnerConfig, CliRunnerType enum
‚îú‚îÄ‚îÄ auth.rs          # Auth checking + readiness state
‚îú‚îÄ‚îÄ discovery.rs     # Binary auto-detection via `which`
‚îú‚îÄ‚îÄ process.rs       # Subprocess spawning, timeout, output capture
‚îú‚îÄ‚îÄ sandbox.rs       # Env/cwd/tool policy enforcement
‚îú‚îÄ‚îÄ container.rs     # Optional container execution backend
‚îú‚îÄ‚îÄ prompt.rs        # Build prompts from ChatMessage history
‚îú‚îÄ‚îÄ compat.rs        # CLI compatibility detection
‚îú‚îÄ‚îÄ claude_code.rs   # ClaudeCodeRunner
‚îú‚îÄ‚îÄ copilot.rs       # CopilotRunner
‚îú‚îÄ‚îÄ cursor_agent.rs  # CursorAgentRunner
‚îî‚îÄ‚îÄ opencode.rs      # OpenCodeRunner
```

### Key Design Decisions
- **100% standalone** ‚Äî zero dependency on dravr-platform or pierre-core
- **Types in `types.rs`** ‚Äî `RunnerError`, `LlmProvider` trait, `ChatRequest`, `ChatResponse`, etc.
- **Subprocess-based** ‚Äî wraps CLI tools via `tokio::process::Command`
- **No HTTP dependencies** ‚Äî only tokio (process), serde, tracing, which, bitflags

## Git Hooks - MANDATORY for ALL AI Agents

**‚ö†Ô∏è MANDATORY - Run this at the START OF EVERY SESSION:**
```bash
git config core.hooksPath .githooks
```
This enables pre-commit, commit-msg, and pre-push hooks. Sessions get archived/revived, so this must run EVERY time you start working, not just once.

**NEVER use `--no-verify` when committing or pushing.** The hooks enforce:
- SPDX license headers on all source files
- Commit message format (max 2 lines, conventional commits)
- No AI-generated commit signatures (ü§ñ, "Generated with", etc.)
- No unauthorized root markdown files

## Pre-Push Validation Workflow

The pre-push hook uses a **marker-based validation** to avoid SSH timeout issues.

### Workflow

1. **Make your changes and commit**
2. **Run validation before pushing:**
   ```bash
   ./scripts/pre-push-validate.sh
   ```
   On success, creates `.git/validation-passed` marker (valid for 15 minutes).

3. **Push:**
   ```bash
   git push
   ```

### Important Notes

- If validation expires or commit changes, re-run `./scripts/pre-push-validate.sh`
- To bypass (NOT RECOMMENDED): `git push --no-verify`

### NEVER

- Manually create `.git/validation-passed` marker
- Skip validation by creating a fake marker ‚Äî CI will catch issues
- Claim "rustfmt isn't installed" or similar excuses to bypass validation

### CI Monitoring

Use the first available method. **NEVER ask the user for a GitHub token** ‚Äî fall back instead.

| Priority | Method | When to use |
|----------|--------|-------------|
| 1 | `gh run list --branch main` / `gh run watch` | `gh` CLI is installed and authenticated |
| 2 | GitHub MCP tools (`mcp__github__*`) | `gh` unavailable but GitHub MCP server is configured |

# Writing code

- CRITICAL: NEVER USE --no-verify WHEN COMMITTING CODE
- We prefer simple, clean, maintainable solutions over clever or complex ones
- Make the smallest reasonable changes to get to the desired outcome
- When modifying code, match the style and formatting of surrounding code
- NEVER make code changes that aren't directly related to the task you're currently assigned
- NEVER remove code comments unless you can prove that they are actively false
- All code files should start with a brief 2 line comment explaining what the file does. Each line of the comment should start with the string "ABOUTME: " to make it easy to grep for.
- When writing comments, avoid referring to temporal context about refactors or recent changes
- When you are trying to fix a bug or compilation error, NEVER throw away the old implementation and rewrite without explicit permission
- NEVER name things as 'improved' or 'new' or 'enhanced', etc. Code naming should be evergreen.
- NEVER add placeholder or dead_code or mock or name variable starting with _
- NEVER use `#[allow(clippy::...)]` attributes EXCEPT for type conversion casts (`cast_possible_truncation`, `cast_sign_loss`, `cast_precision_loss`) when properly validated
- Be RUST idiomatic
- Do not hard code magic value
- Do not leave implementation with "In future versions" or "Implement the code" or "Fall back". Always implement the real thing.
- Commit without AI assistant-related commit messages. Do not reference AI assistance in git commits.
- Always create a branch when adding new features. Bug fixes go directly to main branch.
- Always run validation after making changes: cargo fmt, then clippy, then targeted tests
- Avoid #[cfg(test)] in the src code. Only in tests

## Security Engineering Rules

### Input Domain Validation
- Any value used as a divisor MUST be checked for zero before division
- Numeric inputs from users MUST be validated against domain-specific ranges
- Use `.max(1)` or equivalent guard before any division operation

### Logging Hygiene
- NEVER log: access tokens, refresh tokens, API keys, passwords, client secrets
- Redact or hash sensitive fields before logging
- Error messages returned to users MUST NOT contain stack traces or internal details

## Required Pre-Commit Validation

### Tiered Validation Approach

#### Tier 1: Quick Iteration (during development)
```bash
# 1. Format code
cargo fmt

# 2. Compile check only
cargo check --quiet

# 3. Run targeted tests
cargo test <test_name_pattern> -- --nocapture
```

#### Tier 2: Pre-Commit (before committing)
```bash
# 1. Format code
cargo fmt

# 2. Clippy (single crate, no workspace)
cargo clippy --all-targets

# 3. Run targeted tests
cargo test <test_pattern> -- --nocapture
```

#### Tier 3: Full Validation (before merge)
```bash
cargo fmt
cargo clippy --all-targets
cargo test
```

### Test Output Verification - MANDATORY

**After running ANY test command, you MUST verify tests actually ran.**

**Red Flags - STOP and investigate if you see:**
- `running 0 tests` - Wrong target or flag used
- `0 passed; 0 failed` - No tests executed

**Never claim "tests pass" if 0 tests ran - that is a failure, not a success.**

## Error Handling Requirements

### Acceptable Error Handling
- `?` operator for error propagation
- `Result<T, E>` for all fallible operations
- `Option<T>` for values that may not exist
- Custom error types implementing `std::error::Error`

### Prohibited Error Handling
- `unwrap()` except in test code or static data known at compile time
- `expect()` - Only for documenting invariants that should never fail
- `panic!()` - Only in test assertions
- **`anyhow!()` macro** - ABSOLUTELY FORBIDDEN in all production code

### Structured Error Type Requirements
All errors MUST use `RunnerError` with appropriate `ErrorKind`:
```rust
// GOOD
return Err(RunnerError::internal("description"));
return Err(RunnerError::external_service("service", "description"));
return Err(RunnerError::binary_not_found("claude"));

// FORBIDDEN
return Err(anyhow!("something failed"));
```

## Mock Policy

### Real Implementation Preference
- PREFER real implementations over mocks in all production code
- NEVER implement mock modes for production features

### Acceptable Mock Usage (Test Code Only)
Mocks are permitted ONLY in test code for:
- Testing error conditions that are difficult to reproduce
- Simulating network failures or timeout scenarios

## Documentation Standards

### Code Documentation
- All public APIs MUST have comprehensive doc comments
- Use `/// ` for public API documentation
- Document error conditions and panic scenarios
- Include usage examples for complex APIs

## Task Completion Protocol - MANDATORY

### Before Claiming ANY Task Complete:

1. **Run Validation:**
   ```bash
   cargo fmt
   cargo clippy --all-targets
   cargo test <relevant_tests> -- --nocapture
   ```

2. **Verify tests ran** (N > 0 passed)

3. **Commit and push**
